<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gobservability</title>
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <link rel="stylesheet" href="/static/css/style.css">
</head>
<body>
    <div id="app">
        <h1 class="title-simple">GOBSERVABILITY</h1>
        
        <div id="workersList" 
             hx-get="/nodes" 
             hx-trigger="load, every 2s" 
             hx-swap="innerHTML">
            <div class="loading">Loading nodes...</div>
        </div>
    </div>

    <script>
        console.log('gobservability UI chargÃ©e - Refresh auto toutes les 2s avec hx-preserve');
        
        // Store previous values for change detection
        let previousValues = new Map();

        // Normalize value for comparison (remove extra spaces, standardize format)
        function normalizeValue(value) {
            if (!value) return '';
            return value.trim()
                       .replace(/\s+/g, ' ')  // Replace multiple spaces with single space
                       .replace(/\s*([%KMGTB]+)\s*/g, '$1')  // Remove spaces around units
                       .replace(/(\d+)\.0+([%KMGTB])/g, '$1$2');  // Remove trailing zeros: "23.0%" -> "23%"
        }

        // Initialize or update value tracking
        function trackValueChanges() {
            const elements = document.querySelectorAll('[data-node][data-metric]');
            
            elements.forEach(element => {
                const nodeId = element.dataset.node;
                const metric = element.dataset.metric;
                const key = `${nodeId}-${metric}`;
                
                let currentValue;
                
                // Extract current value from different element types
                if (element.classList.contains('metric-value')) {
                    currentValue = element.textContent;
                } else {
                    // For spans with nested metric-value
                    const valueSpan = element.querySelector('.metric-value');
                    if (valueSpan) {
                        currentValue = valueSpan.textContent;
                    } else {
                        currentValue = element.textContent;
                    }
                }
                
                // Normalize both values for comparison
                const normalizedCurrent = normalizeValue(currentValue);
                const normalizedPrevious = previousValues.has(key) ? normalizeValue(previousValues.get(key)) : '';
                
                // Check if value actually changed (after normalization)
                if (normalizedPrevious && normalizedPrevious !== normalizedCurrent) {
                    // Value changed - animate it
                    animateValueChange(element);
                }
                
                // Store current value for next comparison (store normalized version)
                previousValues.set(key, normalizedCurrent);
            });
        }

        function animateValueChange(element) {
            // Add animation class
            element.classList.add('value-changed');
            
            // Also animate nested metric-value spans if they exist
            const metricValues = element.querySelectorAll('.metric-value');
            metricValues.forEach(span => {
                span.classList.add('value-changed');
            });
            
            // Remove animation class after animation completes (1.5 seconds)
            setTimeout(() => {
                element.classList.remove('value-changed');
                metricValues.forEach(span => {
                    span.classList.remove('value-changed');
                });
            }, 1500);
        }

        // Initialize tracking on first load
        document.addEventListener('DOMContentLoaded', function() {
            trackValueChanges();
        });

        // Track changes after each HTMX update
        document.addEventListener('htmx:afterSwap', function(evt) {
            if (evt.detail.target.id === 'workersList') {
                trackValueChanges();
            }
        });
    </script>
</body>
</html>